<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>armchair API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>armchair</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from bidict import bidict
from datetime import datetime
import os
import dill

#used for armchair file transfer initialized from armchair instructions

class Armchair():
    &#39;&#39;&#39;
    This class facilitates all Armchair interactions over socket. Detailed documentation on the
    protocol can be found in acompanying armchair_specs.txt
    The class maintains a buffer of packets in a conversation, and if the buffer is full, it will
    block until the buffer is emptied. Note however that this abstraction is broken in the case
    of GHOST packets, which are sent without waiting for a ready response and without changing the
    cid  
    ATTRIBUTES:  
        socket sock: a connected socket  
        int buffsize: this is the number of allowed inflight packets (i.e. the number of packets
          to send to the reciever before waiting for a ready response)  
        int cid: the current command id. This is a constantly increasing number. It is used to 
          communicate between Armchair objects about where the other end is in terms of processing
          packages.  
        str name: the name of this armchair object. Used for loging purposes  
        str log_path: the path to the log file for this Armchair  
    CONSTANTS:  
        bidict PACK_TYPES: this is a key for translating between byte codes and string labels
          for different packet types  
        GHOST_TYPES: this is a list of all str types that classify as GHOST packets. i.e. they do
          not go to the buffer, are sent immediately without waiting for a ready. The responses to
          these packets are controlled outside of the Armchair class by the user  
    METHODS:  
        recv() tuple&lt;str,int,Obj&gt;: this should almost never be used by a user. It recieves a
          packet, but without any checking for buffer requirements  
        recv_pack() tuple&lt;str,int,Obj&gt;: this is a wrapped version of recv for user. It will make
          sure that the buffer is managed appropriately if necessary. Returns type, cid, and 
          payload  
        send_pack(pack_type, *args) int: returns the cid it sent. This is used to send a packet 
          of pack_type with args.  
        burn_pipe() void: This command waits until the pipe is clear  
        close() void: terminate the connection  
    &#39;&#39;&#39;

    FTP_EOF = &#39;AFKJldkjvaJKDvJDFDFGHowCouldYouEverHaveThisInAFile&#39;.encode(&#39;ascii&#39;)
    PACK_TYPES = bidict({&#39;init&#39;:b&#39;\x00&#39;,&#39;close&#39;:b&#39;\x01&#39;,&#39;ready&#39;:b&#39;\x03&#39;,&#39;transfer&#39;:b&#39;\x04&#39;,&#39;init_containers&#39;:b&#39;\x05&#39;,&#39;sending_files&#39;:b&#39;\x06&#39;,&#39;pause&#39;:b&#39;\x07&#39;,&#39;stop&#39;:b&#39;\x08&#39;,&#39;continue&#39;:b&#39;\x09&#39;,&#39;stopped&#39;:b&#39;\x0A&#39;,&#39;loc_req&#39;:b&#39;\x0B&#39;,&#39;loc_resp&#39;:b&#39;\x0C&#39;,&#39;home&#39;:b&#39;\x0D&#39;,&#39;make&#39;:b&#39;\x0E&#39;,&#39;mix&#39;:b&#39;\x0F&#39;,&#39;save&#39;:b&#39;\x10&#39;})
    GHOST_TYPES = [&#39;continue&#39;, &#39;stopped&#39;, &#39;loc_resp&#39;,&#39;loc_req&#39;, &#39;save&#39;] #These are necessary because we never want to wait on a
    #buffer. These packs should be send as soon as possible
    #They also do not require ready&#39;s / are not added to inflight packs. Do not modify CID.

    def __init__(self, socket, name, log_path=&#39;&#39;, buffsize=4):
        self.sock = socket
        self.cid = 0
        self.buffsize = buffsize
        self._inflight_packs = []
        #bidirectional dictionary for conversions from byte codes to string names for commands and back
        self.name = name
        self.log_path = log_path
        if not os.path.exists(self.log_path):
            os.makedirs(self.log_path)
        with open(os.path.join(self.log_path, &#39;{}_armchair.log&#39;.format(self.name)), &#39;w&#39;) as armchair_log:
            armchair_log.write(&#39;Armchair Log: {}, {}\n&#39;.format(self.name, datetime.now().strftime(&#39;%H:%M:%S:%f&#39;)))
            

    def get_len(self,header):
        &#39;&#39;&#39;
        params:  
            bytes header: the header of the packet  
        returns:  
            int: the number of bytes in payload  
        &#39;&#39;&#39;
        return int.from_bytes(header[:8], &#39;big&#39;)
    
    def get_type(self,header):
        &#39;&#39;&#39;
        params:  
            bytes header: the header of the packet  
        returns:  
            str: the string name of the command type  
        &#39;&#39;&#39;
        return self.PACK_TYPES.inv[header[8:9]]

    def get_cid(self,header):
        &#39;&#39;&#39;
        params:  
            bytes header: the header of the packet  
        returns:  
            int: the cid of this command  
        &#39;&#39;&#39;
        return int.from_bytes(header[9:17], &#39;big&#39;)
    
    def construct_head(self,n_bytes, pack_type):
        &#39;&#39;&#39;
        params:  
            int n_bytes: the number of bytes in the payload  
            str pack_type: the type of the packet  
        &#39;&#39;&#39;
        if pack_type not in self.GHOST_TYPES:
            self.cid+=1
        return n_bytes.to_bytes(8,&#39;big&#39;) + self.PACK_TYPES[pack_type] + self.cid.to_bytes(8,&#39;big&#39;)

    def recv(self):
        &#39;&#39;&#39;
        If you&#39;re looking at this, you probably want recv_pack. recv is a lower level command that
        will simply get you the next thing in the pipe. recv_pack is a wrapper that gives you the
        next significant thing  
        returns: if packet in buffer  
            str: type of packet  
            int: the cid of the recived packet  
            Obj: the argmuents/payload  
        &#39;&#39;&#39;
        header = self.sock.recv_size(17)
        header_len = self.get_len(header)
        header_type = self.get_type(header)
        header_cid = self.get_cid(header)
        if header_len &gt; 0: #if there were arguments
            payload = self.sock.recv_size(header_len)
            payload = dill.loads(payload)
        else:
            payload = None
        with open(os.path.join(self.log_path, &#39;{}_armchair.log&#39;.format(self.name)), &#39;a+&#39;) as armchair_log:
                armchair_log.write(&#34;{}\trecieved {}, cid {}\n&#34;.format(datetime.now().strftime(&#39;%H:%M:%S:%f&#39;),header_type,self.cid))
        return header_type, header_cid, payload

    def recv_pack(self):
        &#39;&#39;&#39;
        processes the next packet and returns None if nothing to read
        If the next packet was a ready packet it will be ignored and corresponding send will be
        removed  
        returns:  
            str: type of packet  
            int: the cid of the recived packet  
            Obj: the argmuents/payload  
        &#39;&#39;&#39;
        header_type = &#39;ready&#39; #do while
        while header_type == &#39;ready&#39;:
            header_type, header_cid, payload = self.recv()
            if header_type == &#39;ready&#39;:
                self._inflight_packs.remove(header_cid)
        return header_type, header_cid, payload
        
    def send_pack(self, pack_type, *args):
        &#39;&#39;&#39;
        will first check the buffer. If buffer size is exceded will wait on a ready
        constructs a packet and sends it over network  
        params:  
            str pack_type: the type of packet being sent (string form)  
            args*: the objects to pickle  
        returns:  
            int: the cid of the sent packet  
        Postconditions:  
            An armchair packet has been constructed and sent over the socket  
            has created log entry of send  
            cid has been appended to self._inflight_packs  
        &#39;&#39;&#39;
        if len(self._inflight_packs) &gt; self.buffsize and pack_type not in self.GHOST_TYPES:
            self._block_on_ready()
        if args:
            payload = dill.dumps(args)
            n_bytes = len(payload)
            header = self.construct_head(n_bytes, pack_type)
            self.sock.send(header+payload)
        else:
            n_bytes = 0
            header = self.construct_head(n_bytes, pack_type)
            self.sock.send(header)
        with open(os.path.join(self.log_path, &#39;{}_armchair.log&#39;.format(self.name)), &#39;a+&#39;) as armchair_log:
            armchair_log.write(&#34;{}\tsending {}, cid {}\n&#34;.format(datetime.now().strftime(&#39;%H:%M:%S:%f&#39;), pack_type,self.cid))
        if pack_type != &#39;ready&#39; and pack_type not in self.GHOST_TYPES:
            self._inflight_packs.append(self.cid)
        return self.cid

    def burn_pipe(self):
        &#39;&#39;&#39;
        burns through the pipe by reading all of the ready commands  
        Postconditions:  
            Nothing left in the inflight packets buffer  
        &#39;&#39;&#39;
        while self._inflight_packs:
            self._block_on_ready()

            
    def recv_ftp(self):
        &#39;&#39;&#39;
        violates the armchair protocol a little bit because rather than sending an entire  
        file as a payload, ftp is sent in a raw stream with delimiters after a sending_files   
        is sent  
        returns:  
            list&lt;tuple&lt;str:bytes&gt;&gt;: linked filenames and files as bytestreams  
        &#39;&#39;&#39;
        pack_type, cid, arguments = self.recv_pack()
        assert(pack_type == &#39;sending_files&#39;)
        filenames = arguments[0]
        files = []
        for filename in filenames:
            file_bytes = self.sock.recv_until(self.FTP_EOF)
            files.append((filename, file_bytes))
        #ack the send files
        self.send_pack(&#39;ready&#39;)
        return files

    def send_ftp(self, filepaths):
        &#39;&#39;&#39;
        params:  
            list&lt;str&gt; filenames: the names of the files to send  
            str filepath: the path where all the files live  
        &#39;&#39;&#39;
        self.send_pack(&#39;sending_files&#39;, [os.path.basename(filepath) for filepath in filepaths])
        for filepath in filepaths:
            with open(filepath,&#39;rb&#39;) as local_file:
                self.sock.sock.sendfile(local_file)
                self.sock.send(self.FTP_EOF)

    def _block_on_ready(self):
        &#39;&#39;&#39;
        used to block until the other side responds with a &#39;ready&#39; packet  
        Preconditions: self._inflight_packs contains cids of packets that have been sent 
        not yet acknowledged  
        Postconditions:  
            has stalled until a ready command was recieved.  
            The cid in the ready command has been removed from self.inflight_packs  
        &#39;&#39;&#39;
        pack_type, _, arguments = self.recv()
        assert (pack_type == &#39;ready&#39;), &#34;was expecting a ready packet, but instead recieved a {}&#34;.format(pack_type)
        cid = arguments[0]
        self._inflight_packs.remove(cid)

    def close(self):
        &#39;&#39;&#39;
        shutsdown this Armchair. Will burn through all readys before closing connection
        &#39;&#39;&#39;
        self.burn_pipe()
        self.sock.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="armchair.Armchair"><code class="flex name class">
<span>class <span class="ident">Armchair</span></span>
<span>(</span><span>socket, name, log_path='', buffsize=4)</span>
</code></dt>
<dd>
<div class="desc"><p>This class facilitates all Armchair interactions over socket. Detailed documentation on the
protocol can be found in acompanying armchair_specs.txt
The class maintains a buffer of packets in a conversation, and if the buffer is full, it will
block until the buffer is emptied. Note however that this abstraction is broken in the case
of GHOST packets, which are sent without waiting for a ready response and without changing the
cid<br>
ATTRIBUTES:<br>
socket sock: a connected socket<br>
int buffsize: this is the number of allowed inflight packets (i.e. the number of packets
to send to the reciever before waiting for a ready response)<br>
int cid: the current command id. This is a constantly increasing number. It is used to
communicate between Armchair objects about where the other end is in terms of processing
packages.<br>
str name: the name of this armchair object. Used for loging purposes<br>
str log_path: the path to the log file for this Armchair<br>
CONSTANTS:<br>
bidict PACK_TYPES: this is a key for translating between byte codes and string labels
for different packet types<br>
GHOST_TYPES: this is a list of all str types that classify as GHOST packets. i.e. they do
not go to the buffer, are sent immediately without waiting for a ready. The responses to
these packets are controlled outside of the Armchair class by the user<br>
METHODS:<br>
recv() tuple<str,int,Obj>: this should almost never be used by a user. It recieves a
packet, but without any checking for buffer requirements<br>
recv_pack() tuple<str,int,Obj>: this is a wrapped version of recv for user. It will make
sure that the buffer is managed appropriately if necessary. Returns type, cid, and
payload<br>
send_pack(pack_type, *args) int: returns the cid it sent. This is used to send a packet
of pack_type with args.<br>
burn_pipe() void: This command waits until the pipe is clear<br>
close() void: terminate the connection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Armchair():
    &#39;&#39;&#39;
    This class facilitates all Armchair interactions over socket. Detailed documentation on the
    protocol can be found in acompanying armchair_specs.txt
    The class maintains a buffer of packets in a conversation, and if the buffer is full, it will
    block until the buffer is emptied. Note however that this abstraction is broken in the case
    of GHOST packets, which are sent without waiting for a ready response and without changing the
    cid  
    ATTRIBUTES:  
        socket sock: a connected socket  
        int buffsize: this is the number of allowed inflight packets (i.e. the number of packets
          to send to the reciever before waiting for a ready response)  
        int cid: the current command id. This is a constantly increasing number. It is used to 
          communicate between Armchair objects about where the other end is in terms of processing
          packages.  
        str name: the name of this armchair object. Used for loging purposes  
        str log_path: the path to the log file for this Armchair  
    CONSTANTS:  
        bidict PACK_TYPES: this is a key for translating between byte codes and string labels
          for different packet types  
        GHOST_TYPES: this is a list of all str types that classify as GHOST packets. i.e. they do
          not go to the buffer, are sent immediately without waiting for a ready. The responses to
          these packets are controlled outside of the Armchair class by the user  
    METHODS:  
        recv() tuple&lt;str,int,Obj&gt;: this should almost never be used by a user. It recieves a
          packet, but without any checking for buffer requirements  
        recv_pack() tuple&lt;str,int,Obj&gt;: this is a wrapped version of recv for user. It will make
          sure that the buffer is managed appropriately if necessary. Returns type, cid, and 
          payload  
        send_pack(pack_type, *args) int: returns the cid it sent. This is used to send a packet 
          of pack_type with args.  
        burn_pipe() void: This command waits until the pipe is clear  
        close() void: terminate the connection  
    &#39;&#39;&#39;

    FTP_EOF = &#39;AFKJldkjvaJKDvJDFDFGHowCouldYouEverHaveThisInAFile&#39;.encode(&#39;ascii&#39;)
    PACK_TYPES = bidict({&#39;init&#39;:b&#39;\x00&#39;,&#39;close&#39;:b&#39;\x01&#39;,&#39;ready&#39;:b&#39;\x03&#39;,&#39;transfer&#39;:b&#39;\x04&#39;,&#39;init_containers&#39;:b&#39;\x05&#39;,&#39;sending_files&#39;:b&#39;\x06&#39;,&#39;pause&#39;:b&#39;\x07&#39;,&#39;stop&#39;:b&#39;\x08&#39;,&#39;continue&#39;:b&#39;\x09&#39;,&#39;stopped&#39;:b&#39;\x0A&#39;,&#39;loc_req&#39;:b&#39;\x0B&#39;,&#39;loc_resp&#39;:b&#39;\x0C&#39;,&#39;home&#39;:b&#39;\x0D&#39;,&#39;make&#39;:b&#39;\x0E&#39;,&#39;mix&#39;:b&#39;\x0F&#39;,&#39;save&#39;:b&#39;\x10&#39;})
    GHOST_TYPES = [&#39;continue&#39;, &#39;stopped&#39;, &#39;loc_resp&#39;,&#39;loc_req&#39;, &#39;save&#39;] #These are necessary because we never want to wait on a
    #buffer. These packs should be send as soon as possible
    #They also do not require ready&#39;s / are not added to inflight packs. Do not modify CID.

    def __init__(self, socket, name, log_path=&#39;&#39;, buffsize=4):
        self.sock = socket
        self.cid = 0
        self.buffsize = buffsize
        self._inflight_packs = []
        #bidirectional dictionary for conversions from byte codes to string names for commands and back
        self.name = name
        self.log_path = log_path
        if not os.path.exists(self.log_path):
            os.makedirs(self.log_path)
        with open(os.path.join(self.log_path, &#39;{}_armchair.log&#39;.format(self.name)), &#39;w&#39;) as armchair_log:
            armchair_log.write(&#39;Armchair Log: {}, {}\n&#39;.format(self.name, datetime.now().strftime(&#39;%H:%M:%S:%f&#39;)))
            

    def get_len(self,header):
        &#39;&#39;&#39;
        params:  
            bytes header: the header of the packet  
        returns:  
            int: the number of bytes in payload  
        &#39;&#39;&#39;
        return int.from_bytes(header[:8], &#39;big&#39;)
    
    def get_type(self,header):
        &#39;&#39;&#39;
        params:  
            bytes header: the header of the packet  
        returns:  
            str: the string name of the command type  
        &#39;&#39;&#39;
        return self.PACK_TYPES.inv[header[8:9]]

    def get_cid(self,header):
        &#39;&#39;&#39;
        params:  
            bytes header: the header of the packet  
        returns:  
            int: the cid of this command  
        &#39;&#39;&#39;
        return int.from_bytes(header[9:17], &#39;big&#39;)
    
    def construct_head(self,n_bytes, pack_type):
        &#39;&#39;&#39;
        params:  
            int n_bytes: the number of bytes in the payload  
            str pack_type: the type of the packet  
        &#39;&#39;&#39;
        if pack_type not in self.GHOST_TYPES:
            self.cid+=1
        return n_bytes.to_bytes(8,&#39;big&#39;) + self.PACK_TYPES[pack_type] + self.cid.to_bytes(8,&#39;big&#39;)

    def recv(self):
        &#39;&#39;&#39;
        If you&#39;re looking at this, you probably want recv_pack. recv is a lower level command that
        will simply get you the next thing in the pipe. recv_pack is a wrapper that gives you the
        next significant thing  
        returns: if packet in buffer  
            str: type of packet  
            int: the cid of the recived packet  
            Obj: the argmuents/payload  
        &#39;&#39;&#39;
        header = self.sock.recv_size(17)
        header_len = self.get_len(header)
        header_type = self.get_type(header)
        header_cid = self.get_cid(header)
        if header_len &gt; 0: #if there were arguments
            payload = self.sock.recv_size(header_len)
            payload = dill.loads(payload)
        else:
            payload = None
        with open(os.path.join(self.log_path, &#39;{}_armchair.log&#39;.format(self.name)), &#39;a+&#39;) as armchair_log:
                armchair_log.write(&#34;{}\trecieved {}, cid {}\n&#34;.format(datetime.now().strftime(&#39;%H:%M:%S:%f&#39;),header_type,self.cid))
        return header_type, header_cid, payload

    def recv_pack(self):
        &#39;&#39;&#39;
        processes the next packet and returns None if nothing to read
        If the next packet was a ready packet it will be ignored and corresponding send will be
        removed  
        returns:  
            str: type of packet  
            int: the cid of the recived packet  
            Obj: the argmuents/payload  
        &#39;&#39;&#39;
        header_type = &#39;ready&#39; #do while
        while header_type == &#39;ready&#39;:
            header_type, header_cid, payload = self.recv()
            if header_type == &#39;ready&#39;:
                self._inflight_packs.remove(header_cid)
        return header_type, header_cid, payload
        
    def send_pack(self, pack_type, *args):
        &#39;&#39;&#39;
        will first check the buffer. If buffer size is exceded will wait on a ready
        constructs a packet and sends it over network  
        params:  
            str pack_type: the type of packet being sent (string form)  
            args*: the objects to pickle  
        returns:  
            int: the cid of the sent packet  
        Postconditions:  
            An armchair packet has been constructed and sent over the socket  
            has created log entry of send  
            cid has been appended to self._inflight_packs  
        &#39;&#39;&#39;
        if len(self._inflight_packs) &gt; self.buffsize and pack_type not in self.GHOST_TYPES:
            self._block_on_ready()
        if args:
            payload = dill.dumps(args)
            n_bytes = len(payload)
            header = self.construct_head(n_bytes, pack_type)
            self.sock.send(header+payload)
        else:
            n_bytes = 0
            header = self.construct_head(n_bytes, pack_type)
            self.sock.send(header)
        with open(os.path.join(self.log_path, &#39;{}_armchair.log&#39;.format(self.name)), &#39;a+&#39;) as armchair_log:
            armchair_log.write(&#34;{}\tsending {}, cid {}\n&#34;.format(datetime.now().strftime(&#39;%H:%M:%S:%f&#39;), pack_type,self.cid))
        if pack_type != &#39;ready&#39; and pack_type not in self.GHOST_TYPES:
            self._inflight_packs.append(self.cid)
        return self.cid

    def burn_pipe(self):
        &#39;&#39;&#39;
        burns through the pipe by reading all of the ready commands  
        Postconditions:  
            Nothing left in the inflight packets buffer  
        &#39;&#39;&#39;
        while self._inflight_packs:
            self._block_on_ready()

            
    def recv_ftp(self):
        &#39;&#39;&#39;
        violates the armchair protocol a little bit because rather than sending an entire  
        file as a payload, ftp is sent in a raw stream with delimiters after a sending_files   
        is sent  
        returns:  
            list&lt;tuple&lt;str:bytes&gt;&gt;: linked filenames and files as bytestreams  
        &#39;&#39;&#39;
        pack_type, cid, arguments = self.recv_pack()
        assert(pack_type == &#39;sending_files&#39;)
        filenames = arguments[0]
        files = []
        for filename in filenames:
            file_bytes = self.sock.recv_until(self.FTP_EOF)
            files.append((filename, file_bytes))
        #ack the send files
        self.send_pack(&#39;ready&#39;)
        return files

    def send_ftp(self, filepaths):
        &#39;&#39;&#39;
        params:  
            list&lt;str&gt; filenames: the names of the files to send  
            str filepath: the path where all the files live  
        &#39;&#39;&#39;
        self.send_pack(&#39;sending_files&#39;, [os.path.basename(filepath) for filepath in filepaths])
        for filepath in filepaths:
            with open(filepath,&#39;rb&#39;) as local_file:
                self.sock.sock.sendfile(local_file)
                self.sock.send(self.FTP_EOF)

    def _block_on_ready(self):
        &#39;&#39;&#39;
        used to block until the other side responds with a &#39;ready&#39; packet  
        Preconditions: self._inflight_packs contains cids of packets that have been sent 
        not yet acknowledged  
        Postconditions:  
            has stalled until a ready command was recieved.  
            The cid in the ready command has been removed from self.inflight_packs  
        &#39;&#39;&#39;
        pack_type, _, arguments = self.recv()
        assert (pack_type == &#39;ready&#39;), &#34;was expecting a ready packet, but instead recieved a {}&#34;.format(pack_type)
        cid = arguments[0]
        self._inflight_packs.remove(cid)

    def close(self):
        &#39;&#39;&#39;
        shutsdown this Armchair. Will burn through all readys before closing connection
        &#39;&#39;&#39;
        self.burn_pipe()
        self.sock.close()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="armchair.Armchair.FTP_EOF"><code class="name">var <span class="ident">FTP_EOF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="armchair.Armchair.GHOST_TYPES"><code class="name">var <span class="ident">GHOST_TYPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="armchair.Armchair.PACK_TYPES"><code class="name">var <span class="ident">PACK_TYPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="armchair.Armchair.burn_pipe"><code class="name flex">
<span>def <span class="ident">burn_pipe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>burns through the pipe by reading all of the ready commands<br>
Postconditions:<br>
Nothing left in the inflight packets buffer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def burn_pipe(self):
    &#39;&#39;&#39;
    burns through the pipe by reading all of the ready commands  
    Postconditions:  
        Nothing left in the inflight packets buffer  
    &#39;&#39;&#39;
    while self._inflight_packs:
        self._block_on_ready()</code></pre>
</details>
</dd>
<dt id="armchair.Armchair.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>shutsdown this Armchair. Will burn through all readys before closing connection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#39;&#39;&#39;
    shutsdown this Armchair. Will burn through all readys before closing connection
    &#39;&#39;&#39;
    self.burn_pipe()
    self.sock.close()</code></pre>
</details>
</dd>
<dt id="armchair.Armchair.construct_head"><code class="name flex">
<span>def <span class="ident">construct_head</span></span>(<span>self, n_bytes, pack_type)</span>
</code></dt>
<dd>
<div class="desc"><p>params:<br>
int n_bytes: the number of bytes in the payload<br>
str pack_type: the type of the packet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def construct_head(self,n_bytes, pack_type):
    &#39;&#39;&#39;
    params:  
        int n_bytes: the number of bytes in the payload  
        str pack_type: the type of the packet  
    &#39;&#39;&#39;
    if pack_type not in self.GHOST_TYPES:
        self.cid+=1
    return n_bytes.to_bytes(8,&#39;big&#39;) + self.PACK_TYPES[pack_type] + self.cid.to_bytes(8,&#39;big&#39;)</code></pre>
</details>
</dd>
<dt id="armchair.Armchair.get_cid"><code class="name flex">
<span>def <span class="ident">get_cid</span></span>(<span>self, header)</span>
</code></dt>
<dd>
<div class="desc"><p>params:<br>
bytes header: the header of the packet<br>
returns:<br>
int: the cid of this command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cid(self,header):
    &#39;&#39;&#39;
    params:  
        bytes header: the header of the packet  
    returns:  
        int: the cid of this command  
    &#39;&#39;&#39;
    return int.from_bytes(header[9:17], &#39;big&#39;)</code></pre>
</details>
</dd>
<dt id="armchair.Armchair.get_len"><code class="name flex">
<span>def <span class="ident">get_len</span></span>(<span>self, header)</span>
</code></dt>
<dd>
<div class="desc"><p>params:<br>
bytes header: the header of the packet<br>
returns:<br>
int: the number of bytes in payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_len(self,header):
    &#39;&#39;&#39;
    params:  
        bytes header: the header of the packet  
    returns:  
        int: the number of bytes in payload  
    &#39;&#39;&#39;
    return int.from_bytes(header[:8], &#39;big&#39;)</code></pre>
</details>
</dd>
<dt id="armchair.Armchair.get_type"><code class="name flex">
<span>def <span class="ident">get_type</span></span>(<span>self, header)</span>
</code></dt>
<dd>
<div class="desc"><p>params:<br>
bytes header: the header of the packet<br>
returns:<br>
str: the string name of the command type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_type(self,header):
    &#39;&#39;&#39;
    params:  
        bytes header: the header of the packet  
    returns:  
        str: the string name of the command type  
    &#39;&#39;&#39;
    return self.PACK_TYPES.inv[header[8:9]]</code></pre>
</details>
</dd>
<dt id="armchair.Armchair.recv"><code class="name flex">
<span>def <span class="ident">recv</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If you're looking at this, you probably want recv_pack. recv is a lower level command that
will simply get you the next thing in the pipe. recv_pack is a wrapper that gives you the
next significant thing<br>
returns: if packet in buffer<br>
str: type of packet<br>
int: the cid of the recived packet<br>
Obj: the argmuents/payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recv(self):
    &#39;&#39;&#39;
    If you&#39;re looking at this, you probably want recv_pack. recv is a lower level command that
    will simply get you the next thing in the pipe. recv_pack is a wrapper that gives you the
    next significant thing  
    returns: if packet in buffer  
        str: type of packet  
        int: the cid of the recived packet  
        Obj: the argmuents/payload  
    &#39;&#39;&#39;
    header = self.sock.recv_size(17)
    header_len = self.get_len(header)
    header_type = self.get_type(header)
    header_cid = self.get_cid(header)
    if header_len &gt; 0: #if there were arguments
        payload = self.sock.recv_size(header_len)
        payload = dill.loads(payload)
    else:
        payload = None
    with open(os.path.join(self.log_path, &#39;{}_armchair.log&#39;.format(self.name)), &#39;a+&#39;) as armchair_log:
            armchair_log.write(&#34;{}\trecieved {}, cid {}\n&#34;.format(datetime.now().strftime(&#39;%H:%M:%S:%f&#39;),header_type,self.cid))
    return header_type, header_cid, payload</code></pre>
</details>
</dd>
<dt id="armchair.Armchair.recv_ftp"><code class="name flex">
<span>def <span class="ident">recv_ftp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>violates the armchair protocol a little bit because rather than sending an entire<br>
file as a payload, ftp is sent in a raw stream with delimiters after a sending_files <br>
is sent<br>
returns:<br>
list<tuple\<str:bytes>>: linked filenames and files as bytestreams</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recv_ftp(self):
    &#39;&#39;&#39;
    violates the armchair protocol a little bit because rather than sending an entire  
    file as a payload, ftp is sent in a raw stream with delimiters after a sending_files   
    is sent  
    returns:  
        list&lt;tuple&lt;str:bytes&gt;&gt;: linked filenames and files as bytestreams  
    &#39;&#39;&#39;
    pack_type, cid, arguments = self.recv_pack()
    assert(pack_type == &#39;sending_files&#39;)
    filenames = arguments[0]
    files = []
    for filename in filenames:
        file_bytes = self.sock.recv_until(self.FTP_EOF)
        files.append((filename, file_bytes))
    #ack the send files
    self.send_pack(&#39;ready&#39;)
    return files</code></pre>
</details>
</dd>
<dt id="armchair.Armchair.recv_pack"><code class="name flex">
<span>def <span class="ident">recv_pack</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>processes the next packet and returns None if nothing to read
If the next packet was a ready packet it will be ignored and corresponding send will be
removed<br>
returns:<br>
str: type of packet<br>
int: the cid of the recived packet<br>
Obj: the argmuents/payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recv_pack(self):
    &#39;&#39;&#39;
    processes the next packet and returns None if nothing to read
    If the next packet was a ready packet it will be ignored and corresponding send will be
    removed  
    returns:  
        str: type of packet  
        int: the cid of the recived packet  
        Obj: the argmuents/payload  
    &#39;&#39;&#39;
    header_type = &#39;ready&#39; #do while
    while header_type == &#39;ready&#39;:
        header_type, header_cid, payload = self.recv()
        if header_type == &#39;ready&#39;:
            self._inflight_packs.remove(header_cid)
    return header_type, header_cid, payload</code></pre>
</details>
</dd>
<dt id="armchair.Armchair.send_ftp"><code class="name flex">
<span>def <span class="ident">send_ftp</span></span>(<span>self, filepaths)</span>
</code></dt>
<dd>
<div class="desc"><p>params:<br>
list<str> filenames: the names of the files to send<br>
str filepath: the path where all the files live</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_ftp(self, filepaths):
    &#39;&#39;&#39;
    params:  
        list&lt;str&gt; filenames: the names of the files to send  
        str filepath: the path where all the files live  
    &#39;&#39;&#39;
    self.send_pack(&#39;sending_files&#39;, [os.path.basename(filepath) for filepath in filepaths])
    for filepath in filepaths:
        with open(filepath,&#39;rb&#39;) as local_file:
            self.sock.sock.sendfile(local_file)
            self.sock.send(self.FTP_EOF)</code></pre>
</details>
</dd>
<dt id="armchair.Armchair.send_pack"><code class="name flex">
<span>def <span class="ident">send_pack</span></span>(<span>self, pack_type, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>will first check the buffer. If buffer size is exceded will wait on a ready
constructs a packet and sends it over network<br>
params:<br>
str pack_type: the type of packet being sent (string form)<br>
args*: the objects to pickle<br>
returns:<br>
int: the cid of the sent packet<br>
Postconditions:<br>
An armchair packet has been constructed and sent over the socket<br>
has created log entry of send<br>
cid has been appended to self._inflight_packs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_pack(self, pack_type, *args):
    &#39;&#39;&#39;
    will first check the buffer. If buffer size is exceded will wait on a ready
    constructs a packet and sends it over network  
    params:  
        str pack_type: the type of packet being sent (string form)  
        args*: the objects to pickle  
    returns:  
        int: the cid of the sent packet  
    Postconditions:  
        An armchair packet has been constructed and sent over the socket  
        has created log entry of send  
        cid has been appended to self._inflight_packs  
    &#39;&#39;&#39;
    if len(self._inflight_packs) &gt; self.buffsize and pack_type not in self.GHOST_TYPES:
        self._block_on_ready()
    if args:
        payload = dill.dumps(args)
        n_bytes = len(payload)
        header = self.construct_head(n_bytes, pack_type)
        self.sock.send(header+payload)
    else:
        n_bytes = 0
        header = self.construct_head(n_bytes, pack_type)
        self.sock.send(header)
    with open(os.path.join(self.log_path, &#39;{}_armchair.log&#39;.format(self.name)), &#39;a+&#39;) as armchair_log:
        armchair_log.write(&#34;{}\tsending {}, cid {}\n&#34;.format(datetime.now().strftime(&#39;%H:%M:%S:%f&#39;), pack_type,self.cid))
    if pack_type != &#39;ready&#39; and pack_type not in self.GHOST_TYPES:
        self._inflight_packs.append(self.cid)
    return self.cid</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="armchair.Armchair" href="#armchair.Armchair">Armchair</a></code></h4>
<ul class="two-column">
<li><code><a title="armchair.Armchair.FTP_EOF" href="#armchair.Armchair.FTP_EOF">FTP_EOF</a></code></li>
<li><code><a title="armchair.Armchair.GHOST_TYPES" href="#armchair.Armchair.GHOST_TYPES">GHOST_TYPES</a></code></li>
<li><code><a title="armchair.Armchair.PACK_TYPES" href="#armchair.Armchair.PACK_TYPES">PACK_TYPES</a></code></li>
<li><code><a title="armchair.Armchair.burn_pipe" href="#armchair.Armchair.burn_pipe">burn_pipe</a></code></li>
<li><code><a title="armchair.Armchair.close" href="#armchair.Armchair.close">close</a></code></li>
<li><code><a title="armchair.Armchair.construct_head" href="#armchair.Armchair.construct_head">construct_head</a></code></li>
<li><code><a title="armchair.Armchair.get_cid" href="#armchair.Armchair.get_cid">get_cid</a></code></li>
<li><code><a title="armchair.Armchair.get_len" href="#armchair.Armchair.get_len">get_len</a></code></li>
<li><code><a title="armchair.Armchair.get_type" href="#armchair.Armchair.get_type">get_type</a></code></li>
<li><code><a title="armchair.Armchair.recv" href="#armchair.Armchair.recv">recv</a></code></li>
<li><code><a title="armchair.Armchair.recv_ftp" href="#armchair.Armchair.recv_ftp">recv_ftp</a></code></li>
<li><code><a title="armchair.Armchair.recv_pack" href="#armchair.Armchair.recv_pack">recv_pack</a></code></li>
<li><code><a title="armchair.Armchair.send_ftp" href="#armchair.Armchair.send_ftp">send_ftp</a></code></li>
<li><code><a title="armchair.Armchair.send_pack" href="#armchair.Armchair.send_pack">send_pack</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>